Sistema que importa lotes de arquivos .dat.
O sistema deve conseguir importar lotes de arquivo, ler, analisar e depois devolver um relatório dos dados coletados.
Há 3 tipos de dados diferentes no mesmo arquivo, para cada tipo há 1 layout diferente também.
- os itens são:
    - dados do vendedor
      - vendedor tem o id 001 e a linha tem o seguinte formato. 001çCPFçNameçSalary
    - dados do cliente
      - cliente tem o id 002 e a linha tem o seguinte formato. 002çCNPJçNameçBusinessArea
    - dados da venda
      - dados da venda tem o id 003 e a linha tem o seguinte formato. 003çSale IDç[Item ID-Item Quantity-Item Price]çSalesman name
      - dentro da linha de venda existe a linha de itens, que está envolta entre colchetes [].

Dados de Exemplo
O seguinte é um exemplo dos dados que o sistema deve ser capaz de ler.
001ç1234567891234çPedroç50000
001ç3245678865434çPauloç40000.99
002ç2345675434544345çJose da SilvaçRural
002ç2345675433444345çEduardo PereiraçRural
003ç10ç[1-10-100,2-30-2.50,3-40-3.10]çPedro
003ç08ç[1-34-10,2-33-1.50,3-40-0.10]çPaulo

- O sistema deve ler somente arquivos .dat
- Após processar os arquivos no diretório padrão de entrada,
- para cada arquivo de entrada o sistema deve criar um arquivo dentro do diretório de saída padrão, que deve ser <homepath>/data/out.

- O conteúdo do arquivo de saída deve resumir os seguintes dados
    - ● Quantidade de clientes no arquivo de entrada
    - ● Quantidade de vendedor no arquivo de entrada
    - ● ID da venda mais cara
    - ● O pior vendedor

- O arquivo de saída padrão deve se chamar {flat_file_name}.done.dat;

Todo:
  Criar diretórios de entrada dos arquivos e de saída:
    ✔ Criar diretório de entrada <homepath>/data/in @done(19-09-13 19:08)
    ✔ Criar diretório de saída <homepath>/data/out @done(19-09-13 19:08)
    ✔ Criar unittest que testa se os diretórios existem após a execução dos métodos @done(19-09-13 19:08)
  Criar classes que representam cada entidade:
    namedtuple ou dataclass de:
        ✔ customer @done(19-09-15 04:01)
        ✔ seller @done(19-09-15 04:01)
        ✔ orders @done(19-09-15 17:51)
    ✔ função para retornar ID da venda mais cara @done(19-09-16 14:31)
    ✔ função para retornar o pior vendedor @done(19-09-16 23:23)
    ✘ testar instanciar as classes @cancelled(19-09-16 23:23)
  Parser:
    ✔ Criar parser com 1 tipo de delimitador somente @done(19-09-16 00:50)
    ☐ Criar arquivo de config para possibilitar configurar deimilitadores e frequência de busca no diretório
    ✔ Parser deve retornar a quantidade de clientes e vendedores nos arquivos do diretório de entrada (??) @done(19-09-16 14:30)
    ✘ Talvez possam haver também vendas duplicadas... @cancelled(19-09-16 01:43)
  Para cada arquivo .dat processado, uma arquivo.done.dat deve ser gerado:
    ✔ função para processar os dados parseados @done(19-09-16 14:30)
    ✔ função para criar arquivo e armazenar os dados processados @done(19-09-16 16:30)
  Tratamentos:
    ✔ Arquivos sem a extensão .dat devem ser ignorados @done(19-09-16 01:02)
    ☐ Tratamento para arquivos que são .dat, mas sem nenhuma row
    ☐ Tratamento de erros para arquivos que não seguirem o padrão de linha formatada
    ☐ Enter entre linhas
    ✘ Tratar como único através do ID da venda @cancelled(19-09-16 23:53)
        intencionalmento, ou simulando alguma inconsistência no banco de dados, uma venda pode vir com o ID duplicado,
        mas com dados internos diferente... o que fazer nesse caso? remover os ID's duplicados ou
        expor devido a diferença entre os outros dados?
  Finals:
    ✔ typehint @done(19-09-16 16:31)
    ✘ dataclasses @cancelled(19-09-16 16:31)
    ☐ unittest
    ☐ terminal output colorized
